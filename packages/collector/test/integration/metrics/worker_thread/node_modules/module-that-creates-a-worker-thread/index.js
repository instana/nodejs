/*
 * (c) Copyright IBM Corp. 2022
 */

'use strict';

if (process.env.REQUIRE_INSTANA_IN_WORKER_THREAD) {
  require('@instana/collector')();
}

const { Worker, isMainThread, parentPort, workerData } = require('worker_threads');
const http = require('http');

const { delay } = require('@_local/core/test/test_util');

const appPort = process.env.WORKER_THREAD_APP_PORT || 3216;

if (isMainThread) {
  runInMainThread();
} else {
  runInWorkerThread();
}

function runInMainThread() {
  module.exports = function createNewWorkerThread() {
    return new Promise((resolve, reject) => {
      const worker = new Worker(__filename);
      worker.on('message', resolve);
      worker.on('error', reject);
      worker.on('exit', (code) => {
        if (code !== 0)
          reject(new Error(`Worker stopped with exit code ${code}`));
      });
    });
  };
}

async function runInWorkerThread() {
  const requestListener = function (req, res) {
    res.writeHead(201)
    res.end();
  }

  // Creating a server makes sure the worker thread is running long enough so that it could theoretically announce.
  const server = http.createServer(requestListener);
  server.listen(appPort);

  // We continually trigger HTTP requests to ourself in a loop to create HTTP entry spans. It does not really matter for
  // how many iterations we keep the loop going here. The test determines how long the application under test is kept
  // alive and killing the application under test (or rather, its main thread) will also terminate the worker thread,
  // which then also terminates this loop. That's why we arbitrarily use 100 iterations.
  for (let i = 0; i < 100; i++) {
    const res = await fetch(`http://localhost:${appPort}`);
    await delay(300);
  }

  parentPort.postMessage('Worker thread done, kthxbai!');
}
